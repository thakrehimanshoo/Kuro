name: Deploy Kuro to Production

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  DOCKER_IMAGE: kuro
  DOCKER_TAG: ${{ github.sha }}

jobs:
  # Job 1: Build and Test
  build:
    name: Build & Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Build application
        run: npm run build
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
          NEXT_PUBLIC_APP_URL: ${{ secrets.NEXT_PUBLIC_APP_URL }}

      - name: Build Docker image
        run: |
          docker build -t ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }} .
          docker tag ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }} ${{ env.DOCKER_IMAGE }}:latest

  # Job 2: Deploy to VPS
  deploy:
    name: Deploy to VPS
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}

      - name: Add VPS to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to VPS
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          APP_DIR: ${{ secrets.APP_DIR || '/opt/kuro' }}
        run: |
          ssh $VPS_USER@$VPS_HOST << 'ENDSSH'
            set -e

            # Navigate to app directory
            cd ${{ env.APP_DIR || '/opt/kuro' }}

            # Pull latest changes
            git fetch origin main
            git reset --hard origin/main

            # Create .env.production from secrets (if deploy script exists)
            if [ -f "deploy/deploy.sh" ]; then
              chmod +x deploy/deploy.sh
              ./deploy/deploy.sh
            else
              # Manual deployment steps
              docker compose down || true
              docker compose build --no-cache
              docker compose up -d
            fi

            # Health check
            echo "Waiting for application to start..."
            sleep 10

            # Verify deployment
            if curl -sf http://localhost:3000/api/health > /dev/null; then
              echo "‚úÖ Deployment successful!"
            else
              echo "‚ö†Ô∏è Health check failed, checking logs..."
              docker compose logs --tail=50 kuro
              exit 1
            fi
          ENDSSH

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "üöÄ Deployment to production completed successfully!"
          else
            echo "‚ùå Deployment failed. Please check the logs."
          fi

  # Job 3: Post-deployment verification
  verify:
    name: Verify Deployment
    needs: deploy
    runs-on: ubuntu-latest

    steps:
      - name: Wait for deployment to stabilize
        run: sleep 30

      - name: Health check
        run: |
          HEALTH_URL="${{ secrets.NEXT_PUBLIC_APP_URL }}/api/health"
          if [ -z "${{ secrets.NEXT_PUBLIC_APP_URL }}" ]; then
            echo "‚ö†Ô∏è NEXT_PUBLIC_APP_URL not set, skipping external health check"
            exit 0
          fi

          response=$(curl -sf "$HEALTH_URL" || echo "failed")
          if [ "$response" != "failed" ]; then
            echo "‚úÖ Application is healthy!"
            echo "$response"
          else
            echo "‚ùå Health check failed"
            exit 1
          fi

      - name: PWA manifest check
        if: ${{ secrets.NEXT_PUBLIC_APP_URL != '' }}
        run: |
          MANIFEST_URL="${{ secrets.NEXT_PUBLIC_APP_URL }}/manifest.json"
          if curl -sf "$MANIFEST_URL" > /dev/null; then
            echo "‚úÖ PWA manifest accessible"
          else
            echo "‚ö†Ô∏è PWA manifest not accessible"
          fi
